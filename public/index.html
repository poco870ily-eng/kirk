<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nameless AutoJoiner</title>
    <style>
        /* Global Styles */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Gotham', sans-serif;
            background-color: #0f0f16;
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: auto;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }

        #loading-frame {
            background-color: #14141c;
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 255, 170, 0.2);
        }

        #loading-title {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #loading-subtitle {
            font-size: 16px;
            color: #00ffaa;
            margin-bottom: 20px;
        }

        #loading-dots {
            font-size: 24px;
            color: #00ffaa;
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0% { text-shadow: 0 0 5px #00ffaa; }
            50% { text-shadow: 0 0 10px #00ffaa; }
            100% { text-shadow: 0 0 5px #00ffaa; }
        }

        #main-container {
            background-color: #0f0f16;
            border-radius: 16px;
            max-width: 900px;
            width: 100%;
            min-height: 600px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 30px rgba(0, 180, 255, 0.3);
            overflow: hidden;
            position: relative;
        }

        #header {
            background-color: #14141c;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #1e1e28;
        }

        #title {
            font-size: 24px;
            font-weight: bold;
        }

        #status {
            display: flex;
            align-items: center;
        }

        #status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            background-color: #64646e;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.4; }
            100% { opacity: 1; }
        }

        #status-text {
            font-size: 12px;
            color: #9696a0;
        }

        #content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        #left-panel {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background-color: #14141c;
            border-right: 1px solid #1e1e28;
        }

        #events-title {
            font-size: 18px;
            color: #00ffaa;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
        }

        #event-counter {
            font-size: 14px;
            color: #9696a0;
        }

        .event-card {
            background-color: #191923;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .accent-bar {
            width: 4px;
            height: 100%;
            background-color: #00ffaa;
            border-radius: 10px 0 0 10px;
            margin-right: 15px;
        }

        .event-info {
            flex: 1;
        }

        .event-name {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .event-detail {
            font-size: 14px;
            color: #b4b4be;
            margin-bottom: 3px;
        }

        .event-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .join-btn {
            padding: 8px 20px;
            border-radius: 7px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.15s;
            background-color: #00c878;
        }

        .join-btn:hover {
            background-color: #00e68a;
        }

        #right-panel {
            width: 250px;
            padding: 20px;
            background-color: #14141c;
            overflow-y: auto;
        }

        #controls-title {
            font-size: 18px;
            color: #00ffaa;
            margin-bottom: 20px;
        }

        .section {
            background-color: #191923;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        .toggle {
            width: 50px;
            height: 26px;
            background-color: #282832;
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .toggle.active {
            background-color: #00ffaa;
        }

        .toggle-knob {
            width: 20px;
            height: 20px;
            background-color: #464650;
            border-radius: 50%;
            position: absolute;
            top: 3px;
            left: 3px;
            transition: left 0.2s, background-color 0.2s;
        }

        .toggle.active .toggle-knob {
            left: 27px;
            background-color: #ffffff;
        }

        .toggle-label {
            margin-left: 15px;
            font-size: 13px;
            color: #9696a0;
        }

        .toggle.active + .toggle-label {
            color: #00ffaa;
        }

        input[type="text"] {
            background-color: #191923;
            border: none;
            border-radius: 8px;
            padding: 10px;
            color: #e6e6f0;
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 15px;
            font-size: 14px;
        }

        input::placeholder {
            color: #64646e;
        }

        #name-tags, #target-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            max-height: 100px;
            overflow-y: auto;
        }

        .tag {
            background-color: #00b4ff;
            color: #ffffff;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .tag-remove {
            background-color: #ff3c50;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.15s;
        }

        .tag-remove:hover {
            background-color: #ff6677;
        }

        /* Scrollbar Styles */
        ::-webkit-scrollbar {
            width: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background-color: #00ffaa;
            border-radius: 2px;
        }

        ::-webkit-scrollbar-track {
            background-color: #1e1e28;
        }

        /* Mobile Responsive Design */
        @media (max-width: 768px) {
            #main-container {
                border-radius: 0;
                min-height: 100vh;
            }

            #header {
                padding: 10px 15px;
            }

            #title {
                font-size: 20px;
            }

            #content {
                flex-direction: column;
                overflow-y: auto;
            }

            #left-panel {
                border-right: none;
                border-bottom: 1px solid #1e1e28;
                padding: 15px;
            }

            #right-panel {
                width: auto;
                padding: 15px;
            }

            .event-card {
                flex-direction: column;
                align-items: flex-start;
            }

            .accent-bar {
                height: 4px;
                width: 100%;
                border-radius: 10px 10px 0 0;
                margin-right: 0;
                margin-bottom: 10px;
            }

            .event-buttons {
                flex-direction: row;
                width: 100%;
                justify-content: space-between;
                margin-top: 10px;
            }

            .join-btn {
                flex: 1;
                text-align: center;
            }

            input[type="text"] {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div id="loading-frame">
            <div id="loading-title">NAMELESS</div>
            <div id="loading-subtitle">Connecting...</div>
            <div id="loading-dots">●  ○  ○</div>
        </div>
    </div>

    <div id="main-container" style="display: none;">
        <div id="header">
            <div id="title">NAMELESS AUTOJOINER</div>
            <div id="status">
                <div id="status-dot"></div>
                <div id="status-text">OFFLINE</div>
            </div>
        </div>
        <div id="content">
            <div id="left-panel">
                <div id="events-title">
                    EVENT LOGS
                    <span id="event-counter">0 Events</span>
                </div>
                <div id="events-list"></div>
            </div>
            <div id="right-panel">
                <div id="controls-title">CONTROLS</div>
                <div class="section">
                    <div>Auto Join</div>
                    <div class="toggle-container">
                        <div id="auto-toggle" class="toggle">
                            <div class="toggle-knob"></div>
                        </div>
                        <span class="toggle-label">Disabled</span>
                    </div>
                </div>
                <div class="section">
                    <input type="text" id="gen-filter" placeholder="Min Generation (e.g. 10m, 1b)...">
                    <input type="text" id="name-filter" placeholder="Blacklist Pet Name...">
                    <div id="name-tags"></div>
                    <input type="text" id="target-filter" placeholder="Target Pet Name...">
                    <div id="target-tags"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Constants
        const SECRET_KEY = (typeof process !== 'undefined' && process.env ? process.env.SECRET_KEY : "vG7#z9!Lp2@Qw8^Xr6&Nj4*Ta0%Yb1$F");
        const WS_URL = "wss://ja-i04k.onrender.com";
        const BASE_JOIN_URL = "https://nameless-289z.onrender.com/join.html?placeId=109983668079237&jobId=";

        // Variables
        let ws = null;
        let autoJoinEnabled = false;
        let filterByMinGeneration = 0;
        let blackListPets = [];
        let targetPets = [];
        let allEvents = [];
        let seenEvents = {};
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 10;

        // Helper Functions
        function xor(a, b) {
            let result = 0;
            let bitval = 1;
            while (a > 0 || b > 0) {
                if ((a % 2) !== (b % 2)) {
                    result += bitval;
                }
                bitval *= 2;
                a = Math.floor(a / 2);
                b = Math.floor(b / 2);
            }
            return result;
        }

        function decryptData(base64Text, key = SECRET_KEY) {
            // Base64 decode
            const b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            const b64lookup = {};
            for (let i = 0; i < b64chars.length; i++) {
                b64lookup[b64chars[i]] = i;
            }

            const bytes = [];
            for (let i = 0; i < base64Text.length; i += 4) {
                const chunk = base64Text.slice(i, i + 4);
                let n = 0;
                let bits = 0;

                for (let j = 0; j < chunk.length; j++) {
                    const c = chunk[j];
                    if (c === "=") break;
                    const val = b64lookup[c];
                    if (val !== undefined) {
                        n = n * 64 + val;
                        bits += 6;
                    }
                }

                while (bits >= 8) {
                    bits -= 8;
                    const byte = Math.floor(n / Math.pow(2, bits)) % 256;
                    bytes.push(byte);
                }
            }

            // XOR decryption
            const keyBytes = [];
            for (let i = 0; i < key.length; i++) {
                keyBytes.push(key.charCodeAt(i));
            }

            const decrypted = [];
            for (let i = 0; i < bytes.length; i++) {
                const keyIndex = i % keyBytes.length;
                const temp = xor(bytes[i], keyBytes[keyIndex]);
                const decryptedByte = xor(temp, (i % 256));
                decrypted.push(String.fromCharCode(decryptedByte));
            }

            return decrypted.join("");
        }

        function cleanText(s) {
            if (!s) return "";
            s = s.toString();
            s = s.replace(/<\/?[^>]+>/g, "");
            s = s.replace(/&quot;/g, '"').replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#\d+;/g, "");
            s = s.replace(/\s+/g, " ");
            s = s.trim();
            return s;
        }

        function parseNumberWithSuffix(text) {
            if (!text || text === "") return 0;
            const cleaned = text.toLowerCase().replace(/\s+/g, "");
            let numStr = cleaned.replace(/([km]?b?)$/, "");
            let num = parseFloat(numStr) || 0;
            const suffix = cleaned.match(/([km]?b?)$/)?.[0] || "";
            if (suffix.includes("m")) num *= 1000000;
            else if (suffix.includes("b")) num *= 1000000000;
            else if (suffix.includes("k")) num *= 1000;
            return num;
        }

        function calculateFirstGen(pets) {
            if (pets.length === 0) return 0;
            let genStr = pets[0].generation.toString();
            let millions = genStr.match(/\$?(\d+\.?\d*)[mM]/)?.[1];
            if (millions) {
                return parseFloat(millions) * 1000000;
            } else {
                let numMatch = genStr.match(/\d+/)?.[0];
                if (numMatch) {
                    return parseInt(numMatch) || 0;
                }
            }
            return 0;
        }

        function parseEvent(row) {
            let rawModels = row.models || row.models_text || row.modelsText || (row.raw_payload && (row.raw_payload.models || row.raw_payload.models_text)) || "";
            let models = cleanText(rawModels);

            let created_at = row.created_at || "";

            let names = [];
            let generations = [];
            let mutations = [];

            let petBlocks = models.split(",").filter(block => block.includes("Generation"));

            if (petBlocks.length === 0) {
                petBlocks = [models];
            }

            petBlocks.forEach(block => {
                block = block.trim();

                let name = block.match(/^(.*?)Generation\s*:/)?.[1] || "";
                name = name.trim();

                let gen = block.match(/Generation\s*:\s*(.*?)\s+Mutation\s*:/)?.[1] || block.match(/Generation\s*:\s*(\S+)/)?.[1] || "";
                gen = gen.trim();

                let mut = block.match(/Mutation\s*:\s*(.*?)\s+Rarity\s*:/)?.[1] || block.match(/Mutation\s*:\s*(\S+)/)?.[1] || "";
                mut = mut.trim();

                if (rawModels.includes("Yin") && rawModels.includes("Yang")) {
                    const rawMutMatch = rawModels.match(/Mutation\s*:\s*(.*?)\s*Rarity/);
                    if (rawMutMatch && rawMutMatch[1].includes("Yin") && rawMutMatch[1].includes("Yang")) {
                        mut = "Yin Yang";
                    }
                }

                if (name) names.push(name);
                if (gen) generations.push(gen);
                if (mut) mutations.push(mut);
            });

            if (names.length === 0 && models) {
                names.push(models.split(" ")[0] || "Unknown");
            }

            const name = names.join(", ");
            const generation = generations.join(", ");
            const mutation = mutations.join(", ");

            let pets = [];
            const maxPets = Math.max(names.length, generations.length, mutations.length);
            for (let i = 0; i < maxPets; i++) {
                pets.push({
                    name: names[i] || "",
                    generation: generations[i] || "",
                    mutation: mutations[i] || ""
                });
            }

            let player_count = (row.playerCount || row.player_count || (row.raw_payload && (row.raw_payload.playerCount || row.raw_payload.player_count)) || "").toString().replace(/,/g, "").trim();
            let max_players = (row.maxPlayers || row.max_players || (row.raw_payload && (row.raw_payload.maxPlayers || row.raw_payload.max_players)) || "").toString().replace(/,/g, "").trim();
            let jobId = row.jobId || row.job_id || (row.raw_payload && row.raw_payload.jobId) || "";

            let playersDisplay = "";
            if (player_count && max_players) {
                playersDisplay = player_count + "/" + max_players;
            } else if (player_count) {
                playersDisplay = player_count;
            }

            let generationNum = calculateFirstGen(pets);

            return {
                name,
                generation,
                generationNum,
                mutation,
                jobId,
                players: playersDisplay,
                created_at,
                pets
            };
        }

        function isEventTooOld(created_at) {
            if (!created_at) return false;
            const match = created_at.match(/(\d+)-(\d+)-(\d+)T(\d+):(\d+):(\d+)/);
            if (!match) return false;

            const eventTime = new Date(`${match[1]}-${match[2]}-${match[3]}T${match[4]}:${match[5]}:${match[6]}Z`).getTime() / 1000;
            const currentTime = Math.floor(Date.now() / 1000);
            const diff = currentTime - eventTime;

            return diff > 300;
        }

        function passesFilters(data) {
            if (filterByMinGeneration > 0 && data.generationNum < filterByMinGeneration) {
                return false;
            }
            return true;
        }

        // UI Functions
        function updateEvents(decoded) {
            let newEvents = [];

            if (Array.isArray(decoded)) {
                newEvents = decoded;
            } else if (typeof decoded === "object" && (decoded.jobId || decoded.models)) {
                newEvents = [decoded];
            } else {
                return;
            }

            let added = false;

            newEvents.forEach(row => {
                const data = parseEvent(row);
                const eventId = data.jobId;

                if (allEvents.some(e => e.jobId === eventId)) return;

                if (isEventTooOld(row.created_at)) return;

                allEvents.unshift(data);
                added = true;

                // Check for autojoin
                let filteredPets = data.pets.filter(pet => !blackListPets.some(black => pet.name.toLowerCase().includes(black.toLowerCase())));

                if (filteredPets.length === 0) return;

                if (targetPets.length > 0 && !filteredPets.some(pet => targetPets.some(target => pet.name.toLowerCase().includes(target.toLowerCase())))) return;

                const firstFilteredGen = calculateFirstGen(filteredPets);

                const filteredData = {
                    name: filteredPets.map(p => p.name).join(", "),
                    generation: filteredPets.map(p => p.generation).join(", "),
                    generationNum: firstFilteredGen,
                    mutation: filteredPets.map(p => p.mutation).join(", "),
                    jobId: data.jobId,
                    players: data.players,
                    created_at: data.created_at
                };

                if (autoJoinEnabled && passesFilters(filteredData)) {
                    if (!seenEvents[eventId]) {
                        seenEvents[eventId] = true;
                        console.log("[AutoJoin] Would join:", filteredData.name, "Gen:", filteredData.generation, "JobId:", data.jobId);
                        window.location.href = BASE_JOIN_URL + data.jobId;
                    }
                }
            });

            if (added) {
                if (allEvents.length > 50000) allEvents = allEvents.slice(0, 50);
                renderEvents();
            }
        }

        function renderEvents() {
            const eventsList = document.getElementById("events-list");
            eventsList.innerHTML = "";

            let displayedCount = 0;
            allEvents.forEach((data, index) => {
                let filteredPets = data.pets.filter(pet => !blackListPets.some(black => pet.name.toLowerCase().includes(black.toLowerCase())));

                if (filteredPets.length === 0) return;

                if (targetPets.length > 0 && !filteredPets.some(pet => targetPets.some(target => pet.name.toLowerCase().includes(target.toLowerCase())))) return;

                const filteredNames = filteredPets.map(p => p.name).join(", ");
                const filteredGeneration = filteredPets.map(p => p.generation).join(", ");
                const filteredMutation = filteredPets.map(p => p.mutation).join(", ");

                const firstFilteredGen = calculateFirstGen(filteredPets);

                const filteredData = {
                    name: filteredNames,
                    generation: filteredGeneration,
                    generationNum: firstFilteredGen,
                    mutation: filteredMutation,
                    jobId: data.jobId,
                    players: data.players,
                    created_at: data.created_at
                };

                if (passesFilters(filteredData)) {
                    const card = createEventCard(filteredData, index);
                    eventsList.appendChild(card);
                    displayedCount++;
                }
            });

            document.getElementById("event-counter").textContent = `${displayedCount} Events`;
        }

        function createEventCard(data, index) {
            const card = document.createElement("div");
            card.className = "event-card";

            const accentBar = document.createElement("div");
            accentBar.className = "accent-bar";
            card.appendChild(accentBar);

            const info = document.createElement("div");
            info.className = "event-info";

            const name = document.createElement("div");
            name.className = "event-name";
            name.textContent = data.name || "Unknown";
            info.appendChild(name);

            if (data.generation) {
                const gen = document.createElement("div");
                gen.className = "event-detail";
                gen.textContent = `Generation: ${data.generation}`;
                gen.style.color = "#64c8ff";
                info.appendChild(gen);
            }

            if (data.mutation) {
                const mut = document.createElement("div");
                mut.className = "event-detail";
                mut.textContent = `Mutation: ${data.mutation}`;
                mut.style.color = "#ffb450";
                info.appendChild(mut);
            }

            if (data.players) {
                const players = document.createElement("div");
                players.className = "event-detail";
                players.textContent = `Players: ${data.players}`;
                players.style.color = "#aaaaaa";
                info.appendChild(players);
            }

            card.appendChild(info);

            const buttons = document.createElement("div");
            buttons.className = "event-buttons";

            if (data.jobId) {
                const joinBtn = document.createElement("button");
                joinBtn.className = "join-btn";
                joinBtn.textContent = "JOIN";
                joinBtn.onclick = () => {
                    window.location.href = BASE_JOIN_URL + data.jobId;
                };
                buttons.appendChild(joinBtn);
            } else {
                const naBtn = document.createElement("button");
                naBtn.className = "join-btn";
                naBtn.style.backgroundColor = "#2d2d37";
                naBtn.textContent = "N/A";
                naBtn.disabled = true;
                buttons.appendChild(naBtn);
            }

            card.appendChild(buttons);

            return card;
        }

        function createNameTag(name) {
            const tag = document.createElement("div");
            tag.className = "tag";

            const label = document.createElement("span");
            label.textContent = name;
            tag.appendChild(label);

            const remove = document.createElement("div");
            remove.className = "tag-remove";
            remove.textContent = "×";
            remove.onclick = () => {
                blackListPets = blackListPets.filter(n => n !== name);
                tag.remove();
                renderEvents();
            };
            tag.appendChild(remove);

            document.getElementById("name-tags").appendChild(tag);
        }

        function createTargetTag(name) {
            const tag = document.createElement("div");
            tag.className = "tag";

            const label = document.createElement("span");
            label.textContent = name;
            tag.appendChild(label);

            const remove = document.createElement("div");
            remove.className = "tag-remove";
            remove.textContent = "×";
            remove.onclick = () => {
                targetPets = targetPets.filter(n => n !== name);
                tag.remove();
                renderEvents();
            };
            tag.appendChild(remove);

            document.getElementById("target-tags").appendChild(tag);
        }

        // Event Listeners
        document.getElementById("auto-toggle").onclick = () => {
            autoJoinEnabled = !autoJoinEnabled;
            const toggle = document.getElementById("auto-toggle");
            const label = toggle.nextElementSibling;
            if (autoJoinEnabled) {
                toggle.classList.add("active");
                label.textContent = "Enabled";
            } else {
                toggle.classList.remove("active");
                label.textContent = "Disabled";
            }
        };

        document.getElementById("gen-filter").addEventListener("change", (e) => {
            filterByMinGeneration = parseNumberWithSuffix(e.target.value);
            renderEvents();
        });

        document.getElementById("name-filter").addEventListener("keydown", (e) => {
            if (e.key === "Enter" && e.target.value.trim()) {
                const newName = e.target.value.trim();
                if (!blackListPets.some(n => n.toLowerCase() === newName.toLowerCase())) {
                    blackListPets.push(newName);
                    createNameTag(newName);
                    renderEvents();
                }
                e.target.value = "";
            }
        });

        document.getElementById("target-filter").addEventListener("keydown", (e) => {
            if (e.key === "Enter" && e.target.value.trim()) {
                const newName = e.target.value.trim();
                if (!targetPets.some(n => n.toLowerCase() === newName.toLowerCase())) {
                    targetPets.push(newName);
                    createTargetTag(newName);
                    renderEvents();
                }
                e.target.value = "";
            }
        });

        // WebSocket Connection
        function connectWebSocket() {
            document.getElementById("loading-subtitle").textContent = `Connecting... (Attempt ${reconnectAttempts + 1}/${maxReconnectAttempts})`;
            document.getElementById("loading-subtitle").style.color = "#00ffaa";

            ws = new WebSocket(WS_URL);

            let connectionTimeout = setTimeout(() => {
                if (ws.readyState !== 1) {
                    console.warn("[WebSocket] Connection timeout");
                    ws.close();
                }
            }, 10000); // 10 seconds timeout

            ws.onopen = () => {
                clearTimeout(connectionTimeout);
                reconnectAttempts = 0;
                document.getElementById("status-dot").style.backgroundColor = "#00ffaa";
                document.getElementById("status-text").textContent = "ONLINE";
                document.getElementById("status-text").style.color = "#00ffaa";
                document.getElementById("loading-screen").style.display = "none";
                document.getElementById("main-container").style.display = "flex";
            };

            ws.onmessage = (event) => {
                let body = event.data;

                let wrapper;
                try {
                    wrapper = JSON.parse(body);
                } catch (err) {
                    console.warn("[WebSocket] Failed to parse wrapper");
                    return;
                }

                if (wrapper.encrypted && wrapper.data) {
                    let decrypted;
                    try {
                        decrypted = decryptData(wrapper.data);
                    } catch (err) {
                        console.warn("[WebSocket] Decryption error:", err);
                        return;
                    }

                    let decoded;
                    try {
                        decoded = JSON.parse(decrypted);
                    } catch (err) {
                        console.warn("[WebSocket] Failed to parse decrypted data:", err);
                        return;
                    }

                    updateEvents(decoded);
                } else {
                    console.warn("[WebSocket] Received unencrypted data (fallback)");
                    let decoded;
                    try {
                        decoded = JSON.parse(body);
                    } catch (err) {
                        return;
                    }
                    updateEvents(decoded);
                }
            };

            ws.onclose = () => {
                clearTimeout(connectionTimeout);
                console.warn("[WebSocket] Connection closed");
                document.getElementById("status-dot").style.backgroundColor = "#ff6464";
                document.getElementById("status-text").textContent = "OFFLINE";
                document.getElementById("status-text").style.color = "#ff6464";

                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    setTimeout(connectWebSocket, 5000);
                } else {
                    document.getElementById("loading-subtitle").textContent = "Failed to Connect";
                    document.getElementById("loading-subtitle").style.color = "#ff6464";
                }
            };

            ws.onerror = (err) => {
                console.warn("[WebSocket] Error:", err);
                ws.close();
            };
        }

        // Loading Dots Animation
        const dots = ["●  ○  ○", "○  ●  ○", "○  ○  ●"];
        let dotIndex = 0;
        setInterval(() => {
            dotIndex = (dotIndex + 1) % dots.length;
            document.getElementById("loading-dots").textContent = dots[dotIndex];
        }, 300);

        // Start Connection
        connectWebSocket();
    </script>
</body>
</html>
